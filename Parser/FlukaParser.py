# Generated from FlukaParser.g4 by ANTLR 4.6
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"\"\u00cc\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7")
        buf.write(u"\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t")
        buf.write(u"\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22")
        buf.write(u"\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\3\2\6\2.\n\2")
        buf.write(u"\r\2\16\2/\3\3\3\3\3\3\3\3\3\3\3\3\5\38\n\3\3\4\3\4\3")
        buf.write(u"\4\6\4=\n\4\r\4\16\4>\5\4A\n\4\3\5\3\5\6\5E\n\5\r\5\16")
        buf.write(u"\5F\3\6\3\6\6\6K\n\6\r\6\16\6L\3\7\3\7\7\7Q\n\7\f\7\16")
        buf.write(u"\7T\13\7\3\b\3\b\7\bX\n\b\f\b\16\b[\13\b\3\t\3\t\3\t")
        buf.write(u"\6\t`\n\t\r\t\16\ta\3\n\3\n\3\n\3\n\6\nh\n\n\r\n\16\n")
        buf.write(u"i\3\n\3\n\3\n\5\no\n\n\7\nq\n\n\f\n\16\nt\13\n\5\nv\n")
        buf.write(u"\n\3\13\3\13\3\13\3\13\3\13\3\13\5\13~\n\13\3\f\3\f\3")
        buf.write(u"\f\3\f\6\f\u0084\n\f\r\f\16\f\u0085\3\r\3\r\5\r\u008a")
        buf.write(u"\n\r\3\16\3\16\3\16\3\16\5\16\u0090\n\16\3\16\3\16\3")
        buf.write(u"\17\3\17\3\17\3\17\3\17\3\17\3\17\5\17\u009b\n\17\3\20")
        buf.write(u"\3\20\3\20\3\20\3\21\3\21\3\21\3\22\3\22\3\22\5\22\u00a7")
        buf.write(u"\n\22\3\23\3\23\3\23\6\23\u00ac\n\23\r\23\16\23\u00ad")
        buf.write(u"\3\23\3\23\3\24\3\24\3\24\3\24\3\24\6\24\u00b7\n\24\r")
        buf.write(u"\24\16\24\u00b8\3\24\3\24\3\25\3\25\3\25\6\25\u00c0\n")
        buf.write(u"\25\r\25\16\25\u00c1\3\25\3\25\3\26\3\26\6\26\u00c8\n")
        buf.write(u"\26\r\26\16\26\u00c9\3\26\2\2\27\2\4\6\b\n\f\16\20\22")
        buf.write(u"\24\26\30\32\34\36 \"$&(*\2\6\3\2\3\5\4\2\3\3\5\5\3\2")
        buf.write(u"\4\5\3\2\36\37\u00d3\2-\3\2\2\2\4\67\3\2\2\2\6@\3\2\2")
        buf.write(u"\2\bB\3\2\2\2\nH\3\2\2\2\fN\3\2\2\2\16U\3\2\2\2\20_\3")
        buf.write(u"\2\2\2\22u\3\2\2\2\24}\3\2\2\2\26\177\3\2\2\2\30\u0089")
        buf.write(u"\3\2\2\2\32\u008b\3\2\2\2\34\u009a\3\2\2\2\36\u009c\3")
        buf.write(u"\2\2\2 \u00a0\3\2\2\2\"\u00a6\3\2\2\2$\u00a8\3\2\2\2")
        buf.write(u"&\u00b1\3\2\2\2(\u00bc\3\2\2\2*\u00c5\3\2\2\2,.\5\4\3")
        buf.write(u"\2-,\3\2\2\2./\3\2\2\2/-\3\2\2\2/\60\3\2\2\2\60\3\3\2")
        buf.write(u"\2\2\618\5\6\4\2\62\63\5\f\7\2\63\64\5\20\t\2\64\65\7")
        buf.write(u"\17\2\2\658\3\2\2\2\668\5\16\b\2\67\61\3\2\2\2\67\62")
        buf.write(u"\3\2\2\2\67\66\3\2\2\28\5\3\2\2\29A\5\b\5\2:<\5\b\5\2")
        buf.write(u";=\5\n\6\2<;\3\2\2\2=>\3\2\2\2><\3\2\2\2>?\3\2\2\2?A")
        buf.write(u"\3\2\2\2@9\3\2\2\2@:\3\2\2\2A\7\3\2\2\2BD\7\13\2\2CE")
        buf.write(u"\t\2\2\2DC\3\2\2\2EF\3\2\2\2FD\3\2\2\2FG\3\2\2\2G\t\3")
        buf.write(u"\2\2\2HJ\7\f\2\2IK\t\2\2\2JI\3\2\2\2KL\3\2\2\2LJ\3\2")
        buf.write(u"\2\2LM\3\2\2\2M\13\3\2\2\2NR\7\n\2\2OQ\t\2\2\2PO\3\2")
        buf.write(u"\2\2QT\3\2\2\2RP\3\2\2\2RS\3\2\2\2S\r\3\2\2\2TR\3\2\2")
        buf.write(u"\2UY\7\r\2\2VX\t\2\2\2WV\3\2\2\2X[\3\2\2\2YW\3\2\2\2")
        buf.write(u"YZ\3\2\2\2Z\17\3\2\2\2[Y\3\2\2\2\\`\5\22\n\2]`\5\24\13")
        buf.write(u"\2^`\5*\26\2_\\\3\2\2\2_]\3\2\2\2_^\3\2\2\2`a\3\2\2\2")
        buf.write(u"a_\3\2\2\2ab\3\2\2\2b\21\3\2\2\2cv\5\"\22\2de\7\21\2")
        buf.write(u"\2eg\t\3\2\2fh\7\4\2\2gf\3\2\2\2hi\3\2\2\2ig\3\2\2\2")
        buf.write(u"ij\3\2\2\2jv\3\2\2\2kr\7\21\2\2ln\7\6\2\2mo\t\4\2\2n")
        buf.write(u"m\3\2\2\2no\3\2\2\2oq\3\2\2\2pl\3\2\2\2qt\3\2\2\2rp\3")
        buf.write(u"\2\2\2rs\3\2\2\2sv\3\2\2\2tr\3\2\2\2uc\3\2\2\2ud\3\2")
        buf.write(u"\2\2uk\3\2\2\2v\23\3\2\2\2wx\7\23\2\2xy\7\3\2\2y~\5\30")
        buf.write(u"\r\2z{\7\23\2\2{|\7\3\2\2|~\5\26\f\2}w\3\2\2\2}z\3\2")
        buf.write(u"\2\2~\25\3\2\2\2\177\u0080\7 \2\2\u0080\u0083\5\30\r")
        buf.write(u"\2\u0081\u0082\7 \2\2\u0082\u0084\5\30\r\2\u0083\u0081")
        buf.write(u"\3\2\2\2\u0084\u0085\3\2\2\2\u0085\u0083\3\2\2\2\u0085")
        buf.write(u"\u0086\3\2\2\2\u0086\27\3\2\2\2\u0087\u008a\5\34\17\2")
        buf.write(u"\u0088\u008a\5\32\16\2\u0089\u0087\3\2\2\2\u0089\u0088")
        buf.write(u"\3\2\2\2\u008a\31\3\2\2\2\u008b\u008c\t\5\2\2\u008c\u008f")
        buf.write(u"\7!\2\2\u008d\u0090\5\34\17\2\u008e\u0090\5\36\20\2\u008f")
        buf.write(u"\u008d\3\2\2\2\u008f\u008e\3\2\2\2\u0090\u0091\3\2\2")
        buf.write(u"\2\u0091\u0092\7\"\2\2\u0092\33\3\2\2\2\u0093\u009b\5")
        buf.write(u" \21\2\u0094\u0095\5 \21\2\u0095\u0096\5\34\17\2\u0096")
        buf.write(u"\u009b\3\2\2\2\u0097\u0098\5 \21\2\u0098\u0099\5\32\16")
        buf.write(u"\2\u0099\u009b\3\2\2\2\u009a\u0093\3\2\2\2\u009a\u0094")
        buf.write(u"\3\2\2\2\u009a\u0097\3\2\2\2\u009b\35\3\2\2\2\u009c\u009d")
        buf.write(u"\5\34\17\2\u009d\u009e\7 \2\2\u009e\u009f\5\34\17\2\u009f")
        buf.write(u"\37\3\2\2\2\u00a0\u00a1\t\5\2\2\u00a1\u00a2\7\5\2\2\u00a2")
        buf.write(u"!\3\2\2\2\u00a3\u00a7\5$\23\2\u00a4\u00a7\5&\24\2\u00a5")
        buf.write(u"\u00a7\5(\25\2\u00a6\u00a3\3\2\2\2\u00a6\u00a4\3\2\2")
        buf.write(u"\2\u00a6\u00a5\3\2\2\2\u00a7#\3\2\2\2\u00a8\u00a9\7\24")
        buf.write(u"\2\2\u00a9\u00ab\7\4\2\2\u00aa\u00ac\5\22\n\2\u00ab\u00aa")
        buf.write(u"\3\2\2\2\u00ac\u00ad\3\2\2\2\u00ad\u00ab\3\2\2\2\u00ad")
        buf.write(u"\u00ae\3\2\2\2\u00ae\u00af\3\2\2\2\u00af\u00b0\7\27\2")
        buf.write(u"\2\u00b0%\3\2\2\2\u00b1\u00b2\7\25\2\2\u00b2\u00b3\7")
        buf.write(u"\4\2\2\u00b3\u00b4\7\4\2\2\u00b4\u00b6\7\4\2\2\u00b5")
        buf.write(u"\u00b7\5\22\n\2\u00b6\u00b5\3\2\2\2\u00b7\u00b8\3\2\2")
        buf.write(u"\2\u00b8\u00b6\3\2\2\2\u00b8\u00b9\3\2\2\2\u00b9\u00ba")
        buf.write(u"\3\2\2\2\u00ba\u00bb\7\30\2\2\u00bb\'\3\2\2\2\u00bc\u00bd")
        buf.write(u"\7\26\2\2\u00bd\u00bf\t\3\2\2\u00be\u00c0\5\22\n\2\u00bf")
        buf.write(u"\u00be\3\2\2\2\u00c0\u00c1\3\2\2\2\u00c1\u00bf\3\2\2")
        buf.write(u"\2\u00c1\u00c2\3\2\2\2\u00c2\u00c3\3\2\2\2\u00c3\u00c4")
        buf.write(u"\7\31\2\2\u00c4)\3\2\2\2\u00c5\u00c7\7\22\2\2\u00c6\u00c8")
        buf.write(u"\7\5\2\2\u00c7\u00c6\3\2\2\2\u00c8\u00c9\3\2\2\2\u00c9")
        buf.write(u"\u00c7\3\2\2\2\u00c9\u00ca\3\2\2\2\u00ca+\3\2\2\2\32")
        buf.write(u"/\67>@FLRY_ainru}\u0085\u0089\u008f\u009a\u00a6\u00ad")
        buf.write(u"\u00b8\u00c1\u00c9")
        return buf.getvalue()


class FlukaParser ( Parser ):

    grammarFileName = "FlukaParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"'+'", u"'-'", u"'|'", u"'('", u"')'" ]

    symbolicNames = [ u"<INVALID>", u"Integer", u"Float", u"ID", u"Delim", 
                      u"InLineComment", u"Whitespace", u"LineComment", u"GeoBegin", 
                      u"Material", u"Compound", u"Keyword", u"Newline", 
                      u"GeoEnd", u"End", u"BodyCode", u"Lattice", u"RegionName", 
                      u"StartExpansion", u"StartTranslat", u"StartTransform", 
                      u"EndExpansion", u"EndTranslat", u"EndTransform", 
                      u"GeoNewline", u"GeoWhitespace", u"GeoInLineComment", 
                      u"GeoLineComment", u"Plus", u"Minus", u"Bar", u"LParen", 
                      u"RParen" ]

    RULE_model = 0
    RULE_command = 1
    RULE_material_declr = 2
    RULE_material = 3
    RULE_compound = 4
    RULE_geoBegin = 5
    RULE_otherKeywords = 6
    RULE_geocards = 7
    RULE_body = 8
    RULE_region = 9
    RULE_zoneUnion = 10
    RULE_zone = 11
    RULE_subZone = 12
    RULE_expr = 13
    RULE_binaryUnion = 14
    RULE_unaryExpression = 15
    RULE_geoDirective = 16
    RULE_expansion = 17
    RULE_translat = 18
    RULE_transform = 19
    RULE_lattice = 20

    ruleNames =  [ u"model", u"command", u"material_declr", u"material", 
                   u"compound", u"geoBegin", u"otherKeywords", u"geocards", 
                   u"body", u"region", u"zoneUnion", u"zone", u"subZone", 
                   u"expr", u"binaryUnion", u"unaryExpression", u"geoDirective", 
                   u"expansion", u"translat", u"transform", u"lattice" ]

    EOF = Token.EOF
    Integer=1
    Float=2
    ID=3
    Delim=4
    InLineComment=5
    Whitespace=6
    LineComment=7
    GeoBegin=8
    Material=9
    Compound=10
    Keyword=11
    Newline=12
    GeoEnd=13
    End=14
    BodyCode=15
    Lattice=16
    RegionName=17
    StartExpansion=18
    StartTranslat=19
    StartTransform=20
    EndExpansion=21
    EndTranslat=22
    EndTransform=23
    GeoNewline=24
    GeoWhitespace=25
    GeoInLineComment=26
    GeoLineComment=27
    Plus=28
    Minus=29
    Bar=30
    LParen=31
    RParen=32

    def __init__(self, input):
        super(FlukaParser, self).__init__(input)
        self.checkVersion("4.6")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ModelContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ModelContext, self).__init__(parent, invokingState)
            self.parser = parser

        def command(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.CommandContext)
            else:
                return self.getTypedRuleContext(FlukaParser.CommandContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_model

        def enterRule(self, listener):
            if hasattr(listener, "enterModel"):
                listener.enterModel(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitModel"):
                listener.exitModel(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitModel"):
                return visitor.visitModel(self)
            else:
                return visitor.visitChildren(self)




    def model(self):

        localctx = FlukaParser.ModelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_model)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 43 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 42
                self.command()
                self.state = 45 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.GeoBegin) | (1 << FlukaParser.Material) | (1 << FlukaParser.Keyword))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CommandContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.CommandContext, self).__init__(parent, invokingState)
            self.parser = parser

        def material_declr(self):
            return self.getTypedRuleContext(FlukaParser.Material_declrContext,0)


        def geoBegin(self):
            return self.getTypedRuleContext(FlukaParser.GeoBeginContext,0)


        def geocards(self):
            return self.getTypedRuleContext(FlukaParser.GeocardsContext,0)


        def GeoEnd(self):
            return self.getToken(FlukaParser.GeoEnd, 0)

        def otherKeywords(self):
            return self.getTypedRuleContext(FlukaParser.OtherKeywordsContext,0)


        def getRuleIndex(self):
            return FlukaParser.RULE_command

        def enterRule(self, listener):
            if hasattr(listener, "enterCommand"):
                listener.enterCommand(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCommand"):
                listener.exitCommand(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitCommand"):
                return visitor.visitCommand(self)
            else:
                return visitor.visitChildren(self)




    def command(self):

        localctx = FlukaParser.CommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_command)
        try:
            self.state = 53
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FlukaParser.Material]:
                self.enterOuterAlt(localctx, 1)
                self.state = 47
                self.material_declr()
                pass
            elif token in [FlukaParser.GeoBegin]:
                self.enterOuterAlt(localctx, 2)
                self.state = 48
                self.geoBegin()
                self.state = 49
                self.geocards()
                self.state = 50
                self.match(FlukaParser.GeoEnd)
                pass
            elif token in [FlukaParser.Keyword]:
                self.enterOuterAlt(localctx, 3)
                self.state = 52
                self.otherKeywords()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Material_declrContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.Material_declrContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FlukaParser.RULE_material_declr

     
        def copyFrom(self, ctx):
            super(FlukaParser.Material_declrContext, self).copyFrom(ctx)



    class CompoundMaterialContext(Material_declrContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.Material_declrContext)
            super(FlukaParser.CompoundMaterialContext, self).__init__(parser)
            self.copyFrom(ctx)

        def material(self):
            return self.getTypedRuleContext(FlukaParser.MaterialContext,0)

        def compound(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.CompoundContext)
            else:
                return self.getTypedRuleContext(FlukaParser.CompoundContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterCompoundMaterial"):
                listener.enterCompoundMaterial(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCompoundMaterial"):
                listener.exitCompoundMaterial(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitCompoundMaterial"):
                return visitor.visitCompoundMaterial(self)
            else:
                return visitor.visitChildren(self)


    class SimpleMaterialContext(Material_declrContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.Material_declrContext)
            super(FlukaParser.SimpleMaterialContext, self).__init__(parser)
            self.copyFrom(ctx)

        def material(self):
            return self.getTypedRuleContext(FlukaParser.MaterialContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSimpleMaterial"):
                listener.enterSimpleMaterial(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSimpleMaterial"):
                listener.exitSimpleMaterial(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSimpleMaterial"):
                return visitor.visitSimpleMaterial(self)
            else:
                return visitor.visitChildren(self)



    def material_declr(self):

        localctx = FlukaParser.Material_declrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_material_declr)
        self._la = 0 # Token type
        try:
            self.state = 62
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                localctx = FlukaParser.SimpleMaterialContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 55
                self.material()
                pass

            elif la_ == 2:
                localctx = FlukaParser.CompoundMaterialContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 56
                self.material()
                self.state = 58 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 57
                    self.compound()
                    self.state = 60 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==FlukaParser.Compound):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MaterialContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.MaterialContext, self).__init__(parent, invokingState)
            self.parser = parser

        def Material(self):
            return self.getToken(FlukaParser.Material, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def Integer(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Integer)
            else:
                return self.getToken(FlukaParser.Integer, i)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_material

        def enterRule(self, listener):
            if hasattr(listener, "enterMaterial"):
                listener.enterMaterial(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitMaterial"):
                listener.exitMaterial(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitMaterial"):
                return visitor.visitMaterial(self)
            else:
                return visitor.visitChildren(self)




    def material(self):

        localctx = FlukaParser.MaterialContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_material)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64
            self.match(FlukaParser.Material)
            self.state = 66 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 65
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 68 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompoundContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.CompoundContext, self).__init__(parent, invokingState)
            self.parser = parser

        def Compound(self):
            return self.getToken(FlukaParser.Compound, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def Integer(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Integer)
            else:
                return self.getToken(FlukaParser.Integer, i)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_compound

        def enterRule(self, listener):
            if hasattr(listener, "enterCompound"):
                listener.enterCompound(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCompound"):
                listener.exitCompound(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitCompound"):
                return visitor.visitCompound(self)
            else:
                return visitor.visitChildren(self)




    def compound(self):

        localctx = FlukaParser.CompoundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_compound)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 70
            self.match(FlukaParser.Compound)
            self.state = 72 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 71
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 74 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GeoBeginContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.GeoBeginContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GeoBegin(self):
            return self.getToken(FlukaParser.GeoBegin, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def Integer(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Integer)
            else:
                return self.getToken(FlukaParser.Integer, i)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_geoBegin

        def enterRule(self, listener):
            if hasattr(listener, "enterGeoBegin"):
                listener.enterGeoBegin(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGeoBegin"):
                listener.exitGeoBegin(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitGeoBegin"):
                return visitor.visitGeoBegin(self)
            else:
                return visitor.visitChildren(self)




    def geoBegin(self):

        localctx = FlukaParser.GeoBeginContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_geoBegin)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 76
            self.match(FlukaParser.GeoBegin)
            self.state = 80
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0):
                self.state = 77
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 82
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OtherKeywordsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.OtherKeywordsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def Keyword(self):
            return self.getToken(FlukaParser.Keyword, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def Integer(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Integer)
            else:
                return self.getToken(FlukaParser.Integer, i)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_otherKeywords

        def enterRule(self, listener):
            if hasattr(listener, "enterOtherKeywords"):
                listener.enterOtherKeywords(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOtherKeywords"):
                listener.exitOtherKeywords(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitOtherKeywords"):
                return visitor.visitOtherKeywords(self)
            else:
                return visitor.visitChildren(self)




    def otherKeywords(self):

        localctx = FlukaParser.OtherKeywordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_otherKeywords)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.match(FlukaParser.Keyword)
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0):
                self.state = 84
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 89
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GeocardsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.GeocardsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.BodyContext)
            else:
                return self.getTypedRuleContext(FlukaParser.BodyContext,i)


        def region(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.RegionContext)
            else:
                return self.getTypedRuleContext(FlukaParser.RegionContext,i)


        def lattice(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.LatticeContext)
            else:
                return self.getTypedRuleContext(FlukaParser.LatticeContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_geocards

        def enterRule(self, listener):
            if hasattr(listener, "enterGeocards"):
                listener.enterGeocards(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGeocards"):
                listener.exitGeocards(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitGeocards"):
                return visitor.visitGeocards(self)
            else:
                return visitor.visitChildren(self)




    def geocards(self):

        localctx = FlukaParser.GeocardsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_geocards)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 93
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [FlukaParser.BodyCode, FlukaParser.StartExpansion, FlukaParser.StartTranslat, FlukaParser.StartTransform]:
                    self.state = 90
                    self.body()
                    pass
                elif token in [FlukaParser.RegionName]:
                    self.state = 91
                    self.region()
                    pass
                elif token in [FlukaParser.Lattice]:
                    self.state = 92
                    self.lattice()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 95 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.BodyCode) | (1 << FlukaParser.Lattice) | (1 << FlukaParser.RegionName) | (1 << FlukaParser.StartExpansion) | (1 << FlukaParser.StartTranslat) | (1 << FlukaParser.StartTransform))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.BodyContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FlukaParser.RULE_body

     
        def copyFrom(self, ctx):
            super(FlukaParser.BodyContext, self).copyFrom(ctx)



    class BodyDefPunctDelimContext(BodyContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.BodyContext)
            super(FlukaParser.BodyDefPunctDelimContext, self).__init__(parser)
            self.copyFrom(ctx)

        def BodyCode(self):
            return self.getToken(FlukaParser.BodyCode, 0)
        def Delim(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Delim)
            else:
                return self.getToken(FlukaParser.Delim, i)
        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)
        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def enterRule(self, listener):
            if hasattr(listener, "enterBodyDefPunctDelim"):
                listener.enterBodyDefPunctDelim(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBodyDefPunctDelim"):
                listener.exitBodyDefPunctDelim(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBodyDefPunctDelim"):
                return visitor.visitBodyDefPunctDelim(self)
            else:
                return visitor.visitChildren(self)


    class BodyDefSpaceDelimContext(BodyContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.BodyContext)
            super(FlukaParser.BodyDefSpaceDelimContext, self).__init__(parser)
            self.copyFrom(ctx)

        def BodyCode(self):
            return self.getToken(FlukaParser.BodyCode, 0)
        def ID(self):
            return self.getToken(FlukaParser.ID, 0)
        def Integer(self):
            return self.getToken(FlukaParser.Integer, 0)
        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def enterRule(self, listener):
            if hasattr(listener, "enterBodyDefSpaceDelim"):
                listener.enterBodyDefSpaceDelim(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBodyDefSpaceDelim"):
                listener.exitBodyDefSpaceDelim(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBodyDefSpaceDelim"):
                return visitor.visitBodyDefSpaceDelim(self)
            else:
                return visitor.visitChildren(self)


    class GeometryDirectiveContext(BodyContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.BodyContext)
            super(FlukaParser.GeometryDirectiveContext, self).__init__(parser)
            self.copyFrom(ctx)

        def geoDirective(self):
            return self.getTypedRuleContext(FlukaParser.GeoDirectiveContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterGeometryDirective"):
                listener.enterGeometryDirective(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGeometryDirective"):
                listener.exitGeometryDirective(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitGeometryDirective"):
                return visitor.visitGeometryDirective(self)
            else:
                return visitor.visitChildren(self)



    def body(self):

        localctx = FlukaParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.state = 115
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                localctx = FlukaParser.GeometryDirectiveContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 97
                self.geoDirective()
                pass

            elif la_ == 2:
                localctx = FlukaParser.BodyDefSpaceDelimContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 98
                self.match(FlukaParser.BodyCode)
                self.state = 99
                _la = self._input.LA(1)
                if not(_la==FlukaParser.Integer or _la==FlukaParser.ID):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 101 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 100
                    self.match(FlukaParser.Float)
                    self.state = 103 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==FlukaParser.Float):
                        break

                pass

            elif la_ == 3:
                localctx = FlukaParser.BodyDefPunctDelimContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 105
                self.match(FlukaParser.BodyCode)
                self.state = 112
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==FlukaParser.Delim:
                    self.state = 106
                    self.match(FlukaParser.Delim)
                    self.state = 108
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==FlukaParser.Float or _la==FlukaParser.ID:
                        self.state = 107
                        _la = self._input.LA(1)
                        if not(_la==FlukaParser.Float or _la==FlukaParser.ID):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 114
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RegionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.RegionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def RegionName(self):
            return self.getToken(FlukaParser.RegionName, 0)

        def Integer(self):
            return self.getToken(FlukaParser.Integer, 0)

        def zone(self):
            return self.getTypedRuleContext(FlukaParser.ZoneContext,0)


        def zoneUnion(self):
            return self.getTypedRuleContext(FlukaParser.ZoneUnionContext,0)


        def getRuleIndex(self):
            return FlukaParser.RULE_region

        def enterRule(self, listener):
            if hasattr(listener, "enterRegion"):
                listener.enterRegion(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRegion"):
                listener.exitRegion(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRegion"):
                return visitor.visitRegion(self)
            else:
                return visitor.visitChildren(self)




    def region(self):

        localctx = FlukaParser.RegionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_region)
        try:
            self.state = 123
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 117
                self.match(FlukaParser.RegionName)
                self.state = 118
                self.match(FlukaParser.Integer)
                self.state = 119
                self.zone()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 120
                self.match(FlukaParser.RegionName)
                self.state = 121
                self.match(FlukaParser.Integer)
                self.state = 122
                self.zoneUnion()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ZoneUnionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ZoneUnionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def Bar(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Bar)
            else:
                return self.getToken(FlukaParser.Bar, i)

        def zone(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.ZoneContext)
            else:
                return self.getTypedRuleContext(FlukaParser.ZoneContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_zoneUnion

        def enterRule(self, listener):
            if hasattr(listener, "enterZoneUnion"):
                listener.enterZoneUnion(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitZoneUnion"):
                listener.exitZoneUnion(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitZoneUnion"):
                return visitor.visitZoneUnion(self)
            else:
                return visitor.visitChildren(self)




    def zoneUnion(self):

        localctx = FlukaParser.ZoneUnionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_zoneUnion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(FlukaParser.Bar)
            self.state = 126
            self.zone()
            self.state = 129 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 127
                self.match(FlukaParser.Bar)
                self.state = 128
                self.zone()
                self.state = 131 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==FlukaParser.Bar):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ZoneContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ZoneContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(FlukaParser.ExprContext,0)


        def subZone(self):
            return self.getTypedRuleContext(FlukaParser.SubZoneContext,0)


        def getRuleIndex(self):
            return FlukaParser.RULE_zone

        def enterRule(self, listener):
            if hasattr(listener, "enterZone"):
                listener.enterZone(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitZone"):
                listener.exitZone(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitZone"):
                return visitor.visitZone(self)
            else:
                return visitor.visitChildren(self)




    def zone(self):

        localctx = FlukaParser.ZoneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_zone)
        try:
            self.state = 135
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 133
                self.expr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 134
                self.subZone()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SubZoneContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.SubZoneContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LParen(self):
            return self.getToken(FlukaParser.LParen, 0)

        def RParen(self):
            return self.getToken(FlukaParser.RParen, 0)

        def Minus(self):
            return self.getToken(FlukaParser.Minus, 0)

        def Plus(self):
            return self.getToken(FlukaParser.Plus, 0)

        def expr(self):
            return self.getTypedRuleContext(FlukaParser.ExprContext,0)


        def binaryUnion(self):
            return self.getTypedRuleContext(FlukaParser.BinaryUnionContext,0)


        def getRuleIndex(self):
            return FlukaParser.RULE_subZone

        def enterRule(self, listener):
            if hasattr(listener, "enterSubZone"):
                listener.enterSubZone(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSubZone"):
                listener.exitSubZone(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSubZone"):
                return visitor.visitSubZone(self)
            else:
                return visitor.visitChildren(self)




    def subZone(self):

        localctx = FlukaParser.SubZoneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_subZone)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            _la = self._input.LA(1)
            if not(_la==FlukaParser.Plus or _la==FlukaParser.Minus):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 138
            self.match(FlukaParser.LParen)
            self.state = 141
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.state = 139
                self.expr()
                pass

            elif la_ == 2:
                self.state = 140
                self.binaryUnion()
                pass


            self.state = 143
            self.match(FlukaParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ExprContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FlukaParser.RULE_expr

     
        def copyFrom(self, ctx):
            super(FlukaParser.ExprContext, self).copyFrom(ctx)



    class UnaryAndBooleanContext(ExprContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.ExprContext)
            super(FlukaParser.UnaryAndBooleanContext, self).__init__(parser)
            self.copyFrom(ctx)

        def unaryExpression(self):
            return self.getTypedRuleContext(FlukaParser.UnaryExpressionContext,0)

        def expr(self):
            return self.getTypedRuleContext(FlukaParser.ExprContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterUnaryAndBoolean"):
                listener.enterUnaryAndBoolean(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnaryAndBoolean"):
                listener.exitUnaryAndBoolean(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitUnaryAndBoolean"):
                return visitor.visitUnaryAndBoolean(self)
            else:
                return visitor.visitChildren(self)


    class UnaryAndSubZoneContext(ExprContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.ExprContext)
            super(FlukaParser.UnaryAndSubZoneContext, self).__init__(parser)
            self.copyFrom(ctx)

        def unaryExpression(self):
            return self.getTypedRuleContext(FlukaParser.UnaryExpressionContext,0)

        def subZone(self):
            return self.getTypedRuleContext(FlukaParser.SubZoneContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterUnaryAndSubZone"):
                listener.enterUnaryAndSubZone(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnaryAndSubZone"):
                listener.exitUnaryAndSubZone(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitUnaryAndSubZone"):
                return visitor.visitUnaryAndSubZone(self)
            else:
                return visitor.visitChildren(self)


    class SingleUnaryContext(ExprContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.ExprContext)
            super(FlukaParser.SingleUnaryContext, self).__init__(parser)
            self.copyFrom(ctx)

        def unaryExpression(self):
            return self.getTypedRuleContext(FlukaParser.UnaryExpressionContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSingleUnary"):
                listener.enterSingleUnary(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSingleUnary"):
                listener.exitSingleUnary(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSingleUnary"):
                return visitor.visitSingleUnary(self)
            else:
                return visitor.visitChildren(self)



    def expr(self):

        localctx = FlukaParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_expr)
        try:
            self.state = 152
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                localctx = FlukaParser.SingleUnaryContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 145
                self.unaryExpression()
                pass

            elif la_ == 2:
                localctx = FlukaParser.UnaryAndBooleanContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 146
                self.unaryExpression()
                self.state = 147
                self.expr()
                pass

            elif la_ == 3:
                localctx = FlukaParser.UnaryAndSubZoneContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 149
                self.unaryExpression()
                self.state = 150
                self.subZone()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BinaryUnionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.BinaryUnionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.ExprContext)
            else:
                return self.getTypedRuleContext(FlukaParser.ExprContext,i)


        def Bar(self):
            return self.getToken(FlukaParser.Bar, 0)

        def getRuleIndex(self):
            return FlukaParser.RULE_binaryUnion

        def enterRule(self, listener):
            if hasattr(listener, "enterBinaryUnion"):
                listener.enterBinaryUnion(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBinaryUnion"):
                listener.exitBinaryUnion(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBinaryUnion"):
                return visitor.visitBinaryUnion(self)
            else:
                return visitor.visitChildren(self)




    def binaryUnion(self):

        localctx = FlukaParser.BinaryUnionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_binaryUnion)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.expr()
            self.state = 155
            self.match(FlukaParser.Bar)
            self.state = 156
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.UnaryExpressionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(FlukaParser.ID, 0)

        def Minus(self):
            return self.getToken(FlukaParser.Minus, 0)

        def Plus(self):
            return self.getToken(FlukaParser.Plus, 0)

        def getRuleIndex(self):
            return FlukaParser.RULE_unaryExpression

        def enterRule(self, listener):
            if hasattr(listener, "enterUnaryExpression"):
                listener.enterUnaryExpression(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnaryExpression"):
                listener.exitUnaryExpression(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitUnaryExpression"):
                return visitor.visitUnaryExpression(self)
            else:
                return visitor.visitChildren(self)




    def unaryExpression(self):

        localctx = FlukaParser.UnaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_unaryExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            _la = self._input.LA(1)
            if not(_la==FlukaParser.Plus or _la==FlukaParser.Minus):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 159
            self.match(FlukaParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GeoDirectiveContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.GeoDirectiveContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expansion(self):
            return self.getTypedRuleContext(FlukaParser.ExpansionContext,0)


        def translat(self):
            return self.getTypedRuleContext(FlukaParser.TranslatContext,0)


        def transform(self):
            return self.getTypedRuleContext(FlukaParser.TransformContext,0)


        def getRuleIndex(self):
            return FlukaParser.RULE_geoDirective

        def enterRule(self, listener):
            if hasattr(listener, "enterGeoDirective"):
                listener.enterGeoDirective(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGeoDirective"):
                listener.exitGeoDirective(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitGeoDirective"):
                return visitor.visitGeoDirective(self)
            else:
                return visitor.visitChildren(self)




    def geoDirective(self):

        localctx = FlukaParser.GeoDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_geoDirective)
        try:
            self.state = 164
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FlukaParser.StartExpansion]:
                self.enterOuterAlt(localctx, 1)
                self.state = 161
                self.expansion()
                pass
            elif token in [FlukaParser.StartTranslat]:
                self.enterOuterAlt(localctx, 2)
                self.state = 162
                self.translat()
                pass
            elif token in [FlukaParser.StartTransform]:
                self.enterOuterAlt(localctx, 3)
                self.state = 163
                self.transform()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpansionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ExpansionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def StartExpansion(self):
            return self.getToken(FlukaParser.StartExpansion, 0)

        def Float(self):
            return self.getToken(FlukaParser.Float, 0)

        def EndExpansion(self):
            return self.getToken(FlukaParser.EndExpansion, 0)

        def body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.BodyContext)
            else:
                return self.getTypedRuleContext(FlukaParser.BodyContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_expansion

        def enterRule(self, listener):
            if hasattr(listener, "enterExpansion"):
                listener.enterExpansion(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitExpansion"):
                listener.exitExpansion(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitExpansion"):
                return visitor.visitExpansion(self)
            else:
                return visitor.visitChildren(self)




    def expansion(self):

        localctx = FlukaParser.ExpansionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_expansion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.match(FlukaParser.StartExpansion)
            self.state = 167
            self.match(FlukaParser.Float)
            self.state = 169 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 168
                self.body()
                self.state = 171 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.BodyCode) | (1 << FlukaParser.StartExpansion) | (1 << FlukaParser.StartTranslat) | (1 << FlukaParser.StartTransform))) != 0)):
                    break

            self.state = 173
            self.match(FlukaParser.EndExpansion)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TranslatContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.TranslatContext, self).__init__(parent, invokingState)
            self.parser = parser

        def StartTranslat(self):
            return self.getToken(FlukaParser.StartTranslat, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def EndTranslat(self):
            return self.getToken(FlukaParser.EndTranslat, 0)

        def body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.BodyContext)
            else:
                return self.getTypedRuleContext(FlukaParser.BodyContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_translat

        def enterRule(self, listener):
            if hasattr(listener, "enterTranslat"):
                listener.enterTranslat(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTranslat"):
                listener.exitTranslat(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTranslat"):
                return visitor.visitTranslat(self)
            else:
                return visitor.visitChildren(self)




    def translat(self):

        localctx = FlukaParser.TranslatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_translat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.match(FlukaParser.StartTranslat)
            self.state = 176
            self.match(FlukaParser.Float)
            self.state = 177
            self.match(FlukaParser.Float)
            self.state = 178
            self.match(FlukaParser.Float)
            self.state = 180 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 179
                self.body()
                self.state = 182 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.BodyCode) | (1 << FlukaParser.StartExpansion) | (1 << FlukaParser.StartTranslat) | (1 << FlukaParser.StartTransform))) != 0)):
                    break

            self.state = 184
            self.match(FlukaParser.EndTranslat)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TransformContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.TransformContext, self).__init__(parent, invokingState)
            self.parser = parser

        def StartTransform(self):
            return self.getToken(FlukaParser.StartTransform, 0)

        def EndTransform(self):
            return self.getToken(FlukaParser.EndTransform, 0)

        def ID(self):
            return self.getToken(FlukaParser.ID, 0)

        def Integer(self):
            return self.getToken(FlukaParser.Integer, 0)

        def body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.BodyContext)
            else:
                return self.getTypedRuleContext(FlukaParser.BodyContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_transform

        def enterRule(self, listener):
            if hasattr(listener, "enterTransform"):
                listener.enterTransform(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTransform"):
                listener.exitTransform(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTransform"):
                return visitor.visitTransform(self)
            else:
                return visitor.visitChildren(self)




    def transform(self):

        localctx = FlukaParser.TransformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_transform)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(FlukaParser.StartTransform)
            self.state = 187
            _la = self._input.LA(1)
            if not(_la==FlukaParser.Integer or _la==FlukaParser.ID):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 189 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 188
                self.body()
                self.state = 191 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.BodyCode) | (1 << FlukaParser.StartExpansion) | (1 << FlukaParser.StartTranslat) | (1 << FlukaParser.StartTransform))) != 0)):
                    break

            self.state = 193
            self.match(FlukaParser.EndTransform)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LatticeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.LatticeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def Lattice(self):
            return self.getToken(FlukaParser.Lattice, 0)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_lattice

        def enterRule(self, listener):
            if hasattr(listener, "enterLattice"):
                listener.enterLattice(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLattice"):
                listener.exitLattice(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitLattice"):
                return visitor.visitLattice(self)
            else:
                return visitor.visitChildren(self)




    def lattice(self):

        localctx = FlukaParser.LatticeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_lattice)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(FlukaParser.Lattice)
            self.state = 197 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 196
                self.match(FlukaParser.ID)
                self.state = 199 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==FlukaParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





