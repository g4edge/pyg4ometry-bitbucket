# Generated from FlukaParser.g4 by ANTLR 4.6
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"\"\u00c8\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7")
        buf.write(u"\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t")
        buf.write(u"\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22")
        buf.write(u"\4\23\t\23\4\24\t\24\4\25\t\25\3\2\6\2,\n\2\r\2\16\2")
        buf.write(u"-\3\3\3\3\3\3\3\3\3\3\3\3\5\3\66\n\3\3\4\3\4\3\4\6\4")
        buf.write(u";\n\4\r\4\16\4<\5\4?\n\4\3\5\3\5\6\5C\n\5\r\5\16\5D\3")
        buf.write(u"\6\3\6\6\6I\n\6\r\6\16\6J\3\7\3\7\7\7O\n\7\f\7\16\7R")
        buf.write(u"\13\7\3\b\3\b\7\bV\n\b\f\b\16\bY\13\b\3\t\3\t\3\t\6\t")
        buf.write(u"^\n\t\r\t\16\t_\3\n\3\n\3\n\3\n\6\nf\n\n\r\n\16\ng\3")
        buf.write(u"\n\3\n\3\n\5\nm\n\n\7\no\n\n\f\n\16\nr\13\n\5\nt\n\n")
        buf.write(u"\3\13\3\13\3\13\3\13\3\13\3\13\5\13|\n\13\3\f\3\f\3\f")
        buf.write(u"\3\f\6\f\u0082\n\f\r\f\16\f\u0083\3\f\3\f\5\f\u0088\n")
        buf.write(u"\f\3\r\3\r\5\r\u008c\n\r\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write(u"\3\16\3\16\5\16\u0096\n\16\3\17\3\17\3\17\3\17\3\17\3")
        buf.write(u"\20\3\20\3\20\3\21\3\21\3\21\5\21\u00a3\n\21\3\22\3\22")
        buf.write(u"\3\22\6\22\u00a8\n\22\r\22\16\22\u00a9\3\22\3\22\3\23")
        buf.write(u"\3\23\3\23\3\23\3\23\6\23\u00b3\n\23\r\23\16\23\u00b4")
        buf.write(u"\3\23\3\23\3\24\3\24\3\24\6\24\u00bc\n\24\r\24\16\24")
        buf.write(u"\u00bd\3\24\3\24\3\25\3\25\6\25\u00c4\n\25\r\25\16\25")
        buf.write(u"\u00c5\3\25\2\2\26\2\4\6\b\n\f\16\20\22\24\26\30\32\34")
        buf.write(u"\36 \"$&(\2\6\3\2\3\5\4\2\3\3\5\5\3\2\4\5\3\2\36\37\u00d1")
        buf.write(u"\2+\3\2\2\2\4\65\3\2\2\2\6>\3\2\2\2\b@\3\2\2\2\nF\3\2")
        buf.write(u"\2\2\fL\3\2\2\2\16S\3\2\2\2\20]\3\2\2\2\22s\3\2\2\2\24")
        buf.write(u"{\3\2\2\2\26\u0087\3\2\2\2\30\u008b\3\2\2\2\32\u0095")
        buf.write(u"\3\2\2\2\34\u0097\3\2\2\2\36\u009c\3\2\2\2 \u00a2\3\2")
        buf.write(u"\2\2\"\u00a4\3\2\2\2$\u00ad\3\2\2\2&\u00b8\3\2\2\2(\u00c1")
        buf.write(u"\3\2\2\2*,\5\4\3\2+*\3\2\2\2,-\3\2\2\2-+\3\2\2\2-.\3")
        buf.write(u"\2\2\2.\3\3\2\2\2/\66\5\6\4\2\60\61\5\f\7\2\61\62\5\20")
        buf.write(u"\t\2\62\63\7\17\2\2\63\66\3\2\2\2\64\66\5\16\b\2\65/")
        buf.write(u"\3\2\2\2\65\60\3\2\2\2\65\64\3\2\2\2\66\5\3\2\2\2\67")
        buf.write(u"?\5\b\5\28:\5\b\5\29;\5\n\6\2:9\3\2\2\2;<\3\2\2\2<:\3")
        buf.write(u"\2\2\2<=\3\2\2\2=?\3\2\2\2>\67\3\2\2\2>8\3\2\2\2?\7\3")
        buf.write(u"\2\2\2@B\7\13\2\2AC\t\2\2\2BA\3\2\2\2CD\3\2\2\2DB\3\2")
        buf.write(u"\2\2DE\3\2\2\2E\t\3\2\2\2FH\7\f\2\2GI\t\2\2\2HG\3\2\2")
        buf.write(u"\2IJ\3\2\2\2JH\3\2\2\2JK\3\2\2\2K\13\3\2\2\2LP\7\n\2")
        buf.write(u"\2MO\t\2\2\2NM\3\2\2\2OR\3\2\2\2PN\3\2\2\2PQ\3\2\2\2")
        buf.write(u"Q\r\3\2\2\2RP\3\2\2\2SW\7\r\2\2TV\t\2\2\2UT\3\2\2\2V")
        buf.write(u"Y\3\2\2\2WU\3\2\2\2WX\3\2\2\2X\17\3\2\2\2YW\3\2\2\2Z")
        buf.write(u"^\5\22\n\2[^\5\24\13\2\\^\5(\25\2]Z\3\2\2\2][\3\2\2\2")
        buf.write(u"]\\\3\2\2\2^_\3\2\2\2_]\3\2\2\2_`\3\2\2\2`\21\3\2\2\2")
        buf.write(u"at\5 \21\2bc\7\21\2\2ce\t\3\2\2df\7\4\2\2ed\3\2\2\2f")
        buf.write(u"g\3\2\2\2ge\3\2\2\2gh\3\2\2\2ht\3\2\2\2ip\7\21\2\2jl")
        buf.write(u"\7\6\2\2km\t\4\2\2lk\3\2\2\2lm\3\2\2\2mo\3\2\2\2nj\3")
        buf.write(u"\2\2\2or\3\2\2\2pn\3\2\2\2pq\3\2\2\2qt\3\2\2\2rp\3\2")
        buf.write(u"\2\2sa\3\2\2\2sb\3\2\2\2si\3\2\2\2t\23\3\2\2\2uv\7\23")
        buf.write(u"\2\2vw\7\3\2\2w|\5\30\r\2xy\7\23\2\2yz\7\3\2\2z|\5\26")
        buf.write(u"\f\2{u\3\2\2\2{x\3\2\2\2|\25\3\2\2\2}~\7 \2\2~\u0081")
        buf.write(u"\5\30\r\2\177\u0080\7 \2\2\u0080\u0082\5\30\r\2\u0081")
        buf.write(u"\177\3\2\2\2\u0082\u0083\3\2\2\2\u0083\u0081\3\2\2\2")
        buf.write(u"\u0083\u0084\3\2\2\2\u0084\u0088\3\2\2\2\u0085\u0086")
        buf.write(u"\7 \2\2\u0086\u0088\5\30\r\2\u0087}\3\2\2\2\u0087\u0085")
        buf.write(u"\3\2\2\2\u0088\27\3\2\2\2\u0089\u008c\5\32\16\2\u008a")
        buf.write(u"\u008c\5\34\17\2\u008b\u0089\3\2\2\2\u008b\u008a\3\2")
        buf.write(u"\2\2\u008c\31\3\2\2\2\u008d\u0096\5\36\20\2\u008e\u008f")
        buf.write(u"\5\36\20\2\u008f\u0090\5\32\16\2\u0090\u0096\3\2\2\2")
        buf.write(u"\u0091\u0092\5\34\17\2\u0092\u0093\5\32\16\2\u0093\u0096")
        buf.write(u"\3\2\2\2\u0094\u0096\5\34\17\2\u0095\u008d\3\2\2\2\u0095")
        buf.write(u"\u008e\3\2\2\2\u0095\u0091\3\2\2\2\u0095\u0094\3\2\2")
        buf.write(u"\2\u0096\33\3\2\2\2\u0097\u0098\t\5\2\2\u0098\u0099\7")
        buf.write(u"!\2\2\u0099\u009a\5\32\16\2\u009a\u009b\7\"\2\2\u009b")
        buf.write(u"\35\3\2\2\2\u009c\u009d\t\5\2\2\u009d\u009e\7\5\2\2\u009e")
        buf.write(u"\37\3\2\2\2\u009f\u00a3\5\"\22\2\u00a0\u00a3\5$\23\2")
        buf.write(u"\u00a1\u00a3\5&\24\2\u00a2\u009f\3\2\2\2\u00a2\u00a0")
        buf.write(u"\3\2\2\2\u00a2\u00a1\3\2\2\2\u00a3!\3\2\2\2\u00a4\u00a5")
        buf.write(u"\7\24\2\2\u00a5\u00a7\7\4\2\2\u00a6\u00a8\5\22\n\2\u00a7")
        buf.write(u"\u00a6\3\2\2\2\u00a8\u00a9\3\2\2\2\u00a9\u00a7\3\2\2")
        buf.write(u"\2\u00a9\u00aa\3\2\2\2\u00aa\u00ab\3\2\2\2\u00ab\u00ac")
        buf.write(u"\7\27\2\2\u00ac#\3\2\2\2\u00ad\u00ae\7\25\2\2\u00ae\u00af")
        buf.write(u"\7\4\2\2\u00af\u00b0\7\4\2\2\u00b0\u00b2\7\4\2\2\u00b1")
        buf.write(u"\u00b3\5\22\n\2\u00b2\u00b1\3\2\2\2\u00b3\u00b4\3\2\2")
        buf.write(u"\2\u00b4\u00b2\3\2\2\2\u00b4\u00b5\3\2\2\2\u00b5\u00b6")
        buf.write(u"\3\2\2\2\u00b6\u00b7\7\30\2\2\u00b7%\3\2\2\2\u00b8\u00b9")
        buf.write(u"\7\26\2\2\u00b9\u00bb\t\3\2\2\u00ba\u00bc\5\22\n\2\u00bb")
        buf.write(u"\u00ba\3\2\2\2\u00bc\u00bd\3\2\2\2\u00bd\u00bb\3\2\2")
        buf.write(u"\2\u00bd\u00be\3\2\2\2\u00be\u00bf\3\2\2\2\u00bf\u00c0")
        buf.write(u"\7\31\2\2\u00c0\'\3\2\2\2\u00c1\u00c3\7\22\2\2\u00c2")
        buf.write(u"\u00c4\7\5\2\2\u00c3\u00c2\3\2\2\2\u00c4\u00c5\3\2\2")
        buf.write(u"\2\u00c5\u00c3\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6)\3\2")
        buf.write(u"\2\2\32-\65<>DJPW]_glps{\u0083\u0087\u008b\u0095\u00a2")
        buf.write(u"\u00a9\u00b4\u00bd\u00c5")
        return buf.getvalue()


class FlukaParser ( Parser ):

    grammarFileName = "FlukaParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"'+'", u"'-'", u"'|'", u"'('", u"')'" ]

    symbolicNames = [ u"<INVALID>", u"Integer", u"Float", u"ID", u"Delim", 
                      u"InLineComment", u"Whitespace", u"LineComment", u"GeoBegin", 
                      u"Material", u"Compound", u"Keyword", u"Newline", 
                      u"GeoEnd", u"End", u"BodyCode", u"Lattice", u"RegionName", 
                      u"StartExpansion", u"StartTranslat", u"StartTransform", 
                      u"EndExpansion", u"EndTranslat", u"EndTransform", 
                      u"GeoNewline", u"GeoWhitespace", u"GeoInLineComment", 
                      u"GeoLineComment", u"Plus", u"Minus", u"Bar", u"LParen", 
                      u"RParen" ]

    RULE_model = 0
    RULE_command = 1
    RULE_material_declr = 2
    RULE_material = 3
    RULE_compound = 4
    RULE_geoBegin = 5
    RULE_otherKeywords = 6
    RULE_geocards = 7
    RULE_body = 8
    RULE_region = 9
    RULE_zoneUnion = 10
    RULE_zone = 11
    RULE_expr = 12
    RULE_subZone = 13
    RULE_unaryExpression = 14
    RULE_geoDirective = 15
    RULE_expansion = 16
    RULE_translat = 17
    RULE_transform = 18
    RULE_lattice = 19

    ruleNames =  [ u"model", u"command", u"material_declr", u"material", 
                   u"compound", u"geoBegin", u"otherKeywords", u"geocards", 
                   u"body", u"region", u"zoneUnion", u"zone", u"expr", u"subZone", 
                   u"unaryExpression", u"geoDirective", u"expansion", u"translat", 
                   u"transform", u"lattice" ]

    EOF = Token.EOF
    Integer=1
    Float=2
    ID=3
    Delim=4
    InLineComment=5
    Whitespace=6
    LineComment=7
    GeoBegin=8
    Material=9
    Compound=10
    Keyword=11
    Newline=12
    GeoEnd=13
    End=14
    BodyCode=15
    Lattice=16
    RegionName=17
    StartExpansion=18
    StartTranslat=19
    StartTransform=20
    EndExpansion=21
    EndTranslat=22
    EndTransform=23
    GeoNewline=24
    GeoWhitespace=25
    GeoInLineComment=26
    GeoLineComment=27
    Plus=28
    Minus=29
    Bar=30
    LParen=31
    RParen=32

    def __init__(self, input):
        super(FlukaParser, self).__init__(input)
        self.checkVersion("4.6")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ModelContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ModelContext, self).__init__(parent, invokingState)
            self.parser = parser

        def command(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.CommandContext)
            else:
                return self.getTypedRuleContext(FlukaParser.CommandContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_model

        def enterRule(self, listener):
            if hasattr(listener, "enterModel"):
                listener.enterModel(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitModel"):
                listener.exitModel(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitModel"):
                return visitor.visitModel(self)
            else:
                return visitor.visitChildren(self)




    def model(self):

        localctx = FlukaParser.ModelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_model)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 40
                self.command()
                self.state = 43 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.GeoBegin) | (1 << FlukaParser.Material) | (1 << FlukaParser.Keyword))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CommandContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.CommandContext, self).__init__(parent, invokingState)
            self.parser = parser

        def material_declr(self):
            return self.getTypedRuleContext(FlukaParser.Material_declrContext,0)


        def geoBegin(self):
            return self.getTypedRuleContext(FlukaParser.GeoBeginContext,0)


        def geocards(self):
            return self.getTypedRuleContext(FlukaParser.GeocardsContext,0)


        def GeoEnd(self):
            return self.getToken(FlukaParser.GeoEnd, 0)

        def otherKeywords(self):
            return self.getTypedRuleContext(FlukaParser.OtherKeywordsContext,0)


        def getRuleIndex(self):
            return FlukaParser.RULE_command

        def enterRule(self, listener):
            if hasattr(listener, "enterCommand"):
                listener.enterCommand(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCommand"):
                listener.exitCommand(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitCommand"):
                return visitor.visitCommand(self)
            else:
                return visitor.visitChildren(self)




    def command(self):

        localctx = FlukaParser.CommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_command)
        try:
            self.state = 51
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FlukaParser.Material]:
                self.enterOuterAlt(localctx, 1)
                self.state = 45
                self.material_declr()
                pass
            elif token in [FlukaParser.GeoBegin]:
                self.enterOuterAlt(localctx, 2)
                self.state = 46
                self.geoBegin()
                self.state = 47
                self.geocards()
                self.state = 48
                self.match(FlukaParser.GeoEnd)
                pass
            elif token in [FlukaParser.Keyword]:
                self.enterOuterAlt(localctx, 3)
                self.state = 50
                self.otherKeywords()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Material_declrContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.Material_declrContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FlukaParser.RULE_material_declr

     
        def copyFrom(self, ctx):
            super(FlukaParser.Material_declrContext, self).copyFrom(ctx)



    class CompoundMaterialContext(Material_declrContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.Material_declrContext)
            super(FlukaParser.CompoundMaterialContext, self).__init__(parser)
            self.copyFrom(ctx)

        def material(self):
            return self.getTypedRuleContext(FlukaParser.MaterialContext,0)

        def compound(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.CompoundContext)
            else:
                return self.getTypedRuleContext(FlukaParser.CompoundContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterCompoundMaterial"):
                listener.enterCompoundMaterial(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCompoundMaterial"):
                listener.exitCompoundMaterial(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitCompoundMaterial"):
                return visitor.visitCompoundMaterial(self)
            else:
                return visitor.visitChildren(self)


    class SimpleMaterialContext(Material_declrContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.Material_declrContext)
            super(FlukaParser.SimpleMaterialContext, self).__init__(parser)
            self.copyFrom(ctx)

        def material(self):
            return self.getTypedRuleContext(FlukaParser.MaterialContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSimpleMaterial"):
                listener.enterSimpleMaterial(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSimpleMaterial"):
                listener.exitSimpleMaterial(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSimpleMaterial"):
                return visitor.visitSimpleMaterial(self)
            else:
                return visitor.visitChildren(self)



    def material_declr(self):

        localctx = FlukaParser.Material_declrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_material_declr)
        self._la = 0 # Token type
        try:
            self.state = 60
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                localctx = FlukaParser.SimpleMaterialContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 53
                self.material()
                pass

            elif la_ == 2:
                localctx = FlukaParser.CompoundMaterialContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 54
                self.material()
                self.state = 56 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 55
                    self.compound()
                    self.state = 58 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==FlukaParser.Compound):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MaterialContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.MaterialContext, self).__init__(parent, invokingState)
            self.parser = parser

        def Material(self):
            return self.getToken(FlukaParser.Material, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def Integer(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Integer)
            else:
                return self.getToken(FlukaParser.Integer, i)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_material

        def enterRule(self, listener):
            if hasattr(listener, "enterMaterial"):
                listener.enterMaterial(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitMaterial"):
                listener.exitMaterial(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitMaterial"):
                return visitor.visitMaterial(self)
            else:
                return visitor.visitChildren(self)




    def material(self):

        localctx = FlukaParser.MaterialContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_material)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            self.match(FlukaParser.Material)
            self.state = 64 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 63
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 66 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompoundContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.CompoundContext, self).__init__(parent, invokingState)
            self.parser = parser

        def Compound(self):
            return self.getToken(FlukaParser.Compound, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def Integer(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Integer)
            else:
                return self.getToken(FlukaParser.Integer, i)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_compound

        def enterRule(self, listener):
            if hasattr(listener, "enterCompound"):
                listener.enterCompound(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCompound"):
                listener.exitCompound(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitCompound"):
                return visitor.visitCompound(self)
            else:
                return visitor.visitChildren(self)




    def compound(self):

        localctx = FlukaParser.CompoundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_compound)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68
            self.match(FlukaParser.Compound)
            self.state = 70 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 69
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 72 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GeoBeginContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.GeoBeginContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GeoBegin(self):
            return self.getToken(FlukaParser.GeoBegin, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def Integer(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Integer)
            else:
                return self.getToken(FlukaParser.Integer, i)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_geoBegin

        def enterRule(self, listener):
            if hasattr(listener, "enterGeoBegin"):
                listener.enterGeoBegin(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGeoBegin"):
                listener.exitGeoBegin(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitGeoBegin"):
                return visitor.visitGeoBegin(self)
            else:
                return visitor.visitChildren(self)




    def geoBegin(self):

        localctx = FlukaParser.GeoBeginContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_geoBegin)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.match(FlukaParser.GeoBegin)
            self.state = 78
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0):
                self.state = 75
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 80
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OtherKeywordsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.OtherKeywordsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def Keyword(self):
            return self.getToken(FlukaParser.Keyword, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def Integer(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Integer)
            else:
                return self.getToken(FlukaParser.Integer, i)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_otherKeywords

        def enterRule(self, listener):
            if hasattr(listener, "enterOtherKeywords"):
                listener.enterOtherKeywords(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOtherKeywords"):
                listener.exitOtherKeywords(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitOtherKeywords"):
                return visitor.visitOtherKeywords(self)
            else:
                return visitor.visitChildren(self)




    def otherKeywords(self):

        localctx = FlukaParser.OtherKeywordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_otherKeywords)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.match(FlukaParser.Keyword)
            self.state = 85
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0):
                self.state = 82
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.Integer) | (1 << FlukaParser.Float) | (1 << FlukaParser.ID))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 87
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GeocardsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.GeocardsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.BodyContext)
            else:
                return self.getTypedRuleContext(FlukaParser.BodyContext,i)


        def region(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.RegionContext)
            else:
                return self.getTypedRuleContext(FlukaParser.RegionContext,i)


        def lattice(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.LatticeContext)
            else:
                return self.getTypedRuleContext(FlukaParser.LatticeContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_geocards

        def enterRule(self, listener):
            if hasattr(listener, "enterGeocards"):
                listener.enterGeocards(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGeocards"):
                listener.exitGeocards(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitGeocards"):
                return visitor.visitGeocards(self)
            else:
                return visitor.visitChildren(self)




    def geocards(self):

        localctx = FlukaParser.GeocardsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_geocards)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 91
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [FlukaParser.BodyCode, FlukaParser.StartExpansion, FlukaParser.StartTranslat, FlukaParser.StartTransform]:
                    self.state = 88
                    self.body()
                    pass
                elif token in [FlukaParser.RegionName]:
                    self.state = 89
                    self.region()
                    pass
                elif token in [FlukaParser.Lattice]:
                    self.state = 90
                    self.lattice()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 93 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.BodyCode) | (1 << FlukaParser.Lattice) | (1 << FlukaParser.RegionName) | (1 << FlukaParser.StartExpansion) | (1 << FlukaParser.StartTranslat) | (1 << FlukaParser.StartTransform))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.BodyContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FlukaParser.RULE_body

     
        def copyFrom(self, ctx):
            super(FlukaParser.BodyContext, self).copyFrom(ctx)



    class BodyDefPunctDelimContext(BodyContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.BodyContext)
            super(FlukaParser.BodyDefPunctDelimContext, self).__init__(parser)
            self.copyFrom(ctx)

        def BodyCode(self):
            return self.getToken(FlukaParser.BodyCode, 0)
        def Delim(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Delim)
            else:
                return self.getToken(FlukaParser.Delim, i)
        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)
        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def enterRule(self, listener):
            if hasattr(listener, "enterBodyDefPunctDelim"):
                listener.enterBodyDefPunctDelim(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBodyDefPunctDelim"):
                listener.exitBodyDefPunctDelim(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBodyDefPunctDelim"):
                return visitor.visitBodyDefPunctDelim(self)
            else:
                return visitor.visitChildren(self)


    class BodyDefSpaceDelimContext(BodyContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.BodyContext)
            super(FlukaParser.BodyDefSpaceDelimContext, self).__init__(parser)
            self.copyFrom(ctx)

        def BodyCode(self):
            return self.getToken(FlukaParser.BodyCode, 0)
        def ID(self):
            return self.getToken(FlukaParser.ID, 0)
        def Integer(self):
            return self.getToken(FlukaParser.Integer, 0)
        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def enterRule(self, listener):
            if hasattr(listener, "enterBodyDefSpaceDelim"):
                listener.enterBodyDefSpaceDelim(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBodyDefSpaceDelim"):
                listener.exitBodyDefSpaceDelim(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBodyDefSpaceDelim"):
                return visitor.visitBodyDefSpaceDelim(self)
            else:
                return visitor.visitChildren(self)


    class GeometryDirectiveContext(BodyContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.BodyContext)
            super(FlukaParser.GeometryDirectiveContext, self).__init__(parser)
            self.copyFrom(ctx)

        def geoDirective(self):
            return self.getTypedRuleContext(FlukaParser.GeoDirectiveContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterGeometryDirective"):
                listener.enterGeometryDirective(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGeometryDirective"):
                listener.exitGeometryDirective(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitGeometryDirective"):
                return visitor.visitGeometryDirective(self)
            else:
                return visitor.visitChildren(self)



    def body(self):

        localctx = FlukaParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.state = 113
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                localctx = FlukaParser.GeometryDirectiveContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 95
                self.geoDirective()
                pass

            elif la_ == 2:
                localctx = FlukaParser.BodyDefSpaceDelimContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 96
                self.match(FlukaParser.BodyCode)
                self.state = 97
                _la = self._input.LA(1)
                if not(_la==FlukaParser.Integer or _la==FlukaParser.ID):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 99 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 98
                    self.match(FlukaParser.Float)
                    self.state = 101 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==FlukaParser.Float):
                        break

                pass

            elif la_ == 3:
                localctx = FlukaParser.BodyDefPunctDelimContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 103
                self.match(FlukaParser.BodyCode)
                self.state = 110
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==FlukaParser.Delim:
                    self.state = 104
                    self.match(FlukaParser.Delim)
                    self.state = 106
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==FlukaParser.Float or _la==FlukaParser.ID:
                        self.state = 105
                        _la = self._input.LA(1)
                        if not(_la==FlukaParser.Float or _la==FlukaParser.ID):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 112
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RegionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.RegionContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FlukaParser.RULE_region

     
        def copyFrom(self, ctx):
            super(FlukaParser.RegionContext, self).copyFrom(ctx)



    class ComplexRegionContext(RegionContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.RegionContext)
            super(FlukaParser.ComplexRegionContext, self).__init__(parser)
            self.copyFrom(ctx)

        def RegionName(self):
            return self.getToken(FlukaParser.RegionName, 0)
        def Integer(self):
            return self.getToken(FlukaParser.Integer, 0)
        def zoneUnion(self):
            return self.getTypedRuleContext(FlukaParser.ZoneUnionContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterComplexRegion"):
                listener.enterComplexRegion(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitComplexRegion"):
                listener.exitComplexRegion(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitComplexRegion"):
                return visitor.visitComplexRegion(self)
            else:
                return visitor.visitChildren(self)


    class SimpleRegionContext(RegionContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.RegionContext)
            super(FlukaParser.SimpleRegionContext, self).__init__(parser)
            self.copyFrom(ctx)

        def RegionName(self):
            return self.getToken(FlukaParser.RegionName, 0)
        def Integer(self):
            return self.getToken(FlukaParser.Integer, 0)
        def zone(self):
            return self.getTypedRuleContext(FlukaParser.ZoneContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSimpleRegion"):
                listener.enterSimpleRegion(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSimpleRegion"):
                listener.exitSimpleRegion(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSimpleRegion"):
                return visitor.visitSimpleRegion(self)
            else:
                return visitor.visitChildren(self)



    def region(self):

        localctx = FlukaParser.RegionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_region)
        try:
            self.state = 121
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                localctx = FlukaParser.SimpleRegionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 115
                self.match(FlukaParser.RegionName)
                self.state = 116
                self.match(FlukaParser.Integer)
                self.state = 117
                self.zone()
                pass

            elif la_ == 2:
                localctx = FlukaParser.ComplexRegionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 118
                self.match(FlukaParser.RegionName)
                self.state = 119
                self.match(FlukaParser.Integer)
                self.state = 120
                self.zoneUnion()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ZoneUnionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ZoneUnionContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FlukaParser.RULE_zoneUnion

     
        def copyFrom(self, ctx):
            super(FlukaParser.ZoneUnionContext, self).copyFrom(ctx)



    class MultipleUnionContext(ZoneUnionContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.ZoneUnionContext)
            super(FlukaParser.MultipleUnionContext, self).__init__(parser)
            self.copyFrom(ctx)

        def Bar(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Bar)
            else:
                return self.getToken(FlukaParser.Bar, i)
        def zone(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.ZoneContext)
            else:
                return self.getTypedRuleContext(FlukaParser.ZoneContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterMultipleUnion"):
                listener.enterMultipleUnion(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitMultipleUnion"):
                listener.exitMultipleUnion(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitMultipleUnion"):
                return visitor.visitMultipleUnion(self)
            else:
                return visitor.visitChildren(self)


    class SingleUnionContext(ZoneUnionContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.ZoneUnionContext)
            super(FlukaParser.SingleUnionContext, self).__init__(parser)
            self.copyFrom(ctx)

        def Bar(self):
            return self.getToken(FlukaParser.Bar, 0)
        def zone(self):
            return self.getTypedRuleContext(FlukaParser.ZoneContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSingleUnion"):
                listener.enterSingleUnion(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSingleUnion"):
                listener.exitSingleUnion(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSingleUnion"):
                return visitor.visitSingleUnion(self)
            else:
                return visitor.visitChildren(self)



    def zoneUnion(self):

        localctx = FlukaParser.ZoneUnionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_zoneUnion)
        self._la = 0 # Token type
        try:
            self.state = 133
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                localctx = FlukaParser.MultipleUnionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 123
                self.match(FlukaParser.Bar)
                self.state = 124
                self.zone()
                self.state = 127 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 125
                    self.match(FlukaParser.Bar)
                    self.state = 126
                    self.zone()
                    self.state = 129 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==FlukaParser.Bar):
                        break

                pass

            elif la_ == 2:
                localctx = FlukaParser.SingleUnionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 131
                self.match(FlukaParser.Bar)
                self.state = 132
                self.zone()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ZoneContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ZoneContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(FlukaParser.ExprContext,0)


        def subZone(self):
            return self.getTypedRuleContext(FlukaParser.SubZoneContext,0)


        def getRuleIndex(self):
            return FlukaParser.RULE_zone

        def enterRule(self, listener):
            if hasattr(listener, "enterZone"):
                listener.enterZone(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitZone"):
                listener.exitZone(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitZone"):
                return visitor.visitZone(self)
            else:
                return visitor.visitChildren(self)




    def zone(self):

        localctx = FlukaParser.ZoneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_zone)
        try:
            self.state = 137
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 135
                self.expr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 136
                self.subZone()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ExprContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return FlukaParser.RULE_expr

     
        def copyFrom(self, ctx):
            super(FlukaParser.ExprContext, self).copyFrom(ctx)



    class UnaryAndBooleanContext(ExprContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.ExprContext)
            super(FlukaParser.UnaryAndBooleanContext, self).__init__(parser)
            self.copyFrom(ctx)

        def unaryExpression(self):
            return self.getTypedRuleContext(FlukaParser.UnaryExpressionContext,0)

        def expr(self):
            return self.getTypedRuleContext(FlukaParser.ExprContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterUnaryAndBoolean"):
                listener.enterUnaryAndBoolean(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnaryAndBoolean"):
                listener.exitUnaryAndBoolean(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitUnaryAndBoolean"):
                return visitor.visitUnaryAndBoolean(self)
            else:
                return visitor.visitChildren(self)


    class OneSubZoneContext(ExprContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.ExprContext)
            super(FlukaParser.OneSubZoneContext, self).__init__(parser)
            self.copyFrom(ctx)

        def subZone(self):
            return self.getTypedRuleContext(FlukaParser.SubZoneContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterOneSubZone"):
                listener.enterOneSubZone(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOneSubZone"):
                listener.exitOneSubZone(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitOneSubZone"):
                return visitor.visitOneSubZone(self)
            else:
                return visitor.visitChildren(self)


    class UnaryAndSubZoneContext(ExprContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.ExprContext)
            super(FlukaParser.UnaryAndSubZoneContext, self).__init__(parser)
            self.copyFrom(ctx)

        def subZone(self):
            return self.getTypedRuleContext(FlukaParser.SubZoneContext,0)

        def expr(self):
            return self.getTypedRuleContext(FlukaParser.ExprContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterUnaryAndSubZone"):
                listener.enterUnaryAndSubZone(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnaryAndSubZone"):
                listener.exitUnaryAndSubZone(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitUnaryAndSubZone"):
                return visitor.visitUnaryAndSubZone(self)
            else:
                return visitor.visitChildren(self)


    class SingleUnaryContext(ExprContext):

        def __init__(self, parser, ctx): # actually a FlukaParser.ExprContext)
            super(FlukaParser.SingleUnaryContext, self).__init__(parser)
            self.copyFrom(ctx)

        def unaryExpression(self):
            return self.getTypedRuleContext(FlukaParser.UnaryExpressionContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSingleUnary"):
                listener.enterSingleUnary(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSingleUnary"):
                listener.exitSingleUnary(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSingleUnary"):
                return visitor.visitSingleUnary(self)
            else:
                return visitor.visitChildren(self)



    def expr(self):

        localctx = FlukaParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_expr)
        try:
            self.state = 147
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                localctx = FlukaParser.SingleUnaryContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 139
                self.unaryExpression()
                pass

            elif la_ == 2:
                localctx = FlukaParser.UnaryAndBooleanContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 140
                self.unaryExpression()
                self.state = 141
                self.expr()
                pass

            elif la_ == 3:
                localctx = FlukaParser.UnaryAndSubZoneContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 143
                self.subZone()
                self.state = 144
                self.expr()
                pass

            elif la_ == 4:
                localctx = FlukaParser.OneSubZoneContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 146
                self.subZone()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SubZoneContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.SubZoneContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LParen(self):
            return self.getToken(FlukaParser.LParen, 0)

        def expr(self):
            return self.getTypedRuleContext(FlukaParser.ExprContext,0)


        def RParen(self):
            return self.getToken(FlukaParser.RParen, 0)

        def Minus(self):
            return self.getToken(FlukaParser.Minus, 0)

        def Plus(self):
            return self.getToken(FlukaParser.Plus, 0)

        def getRuleIndex(self):
            return FlukaParser.RULE_subZone

        def enterRule(self, listener):
            if hasattr(listener, "enterSubZone"):
                listener.enterSubZone(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSubZone"):
                listener.exitSubZone(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSubZone"):
                return visitor.visitSubZone(self)
            else:
                return visitor.visitChildren(self)




    def subZone(self):

        localctx = FlukaParser.SubZoneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_subZone)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            _la = self._input.LA(1)
            if not(_la==FlukaParser.Plus or _la==FlukaParser.Minus):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 150
            self.match(FlukaParser.LParen)
            self.state = 151
            self.expr()
            self.state = 152
            self.match(FlukaParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.UnaryExpressionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(FlukaParser.ID, 0)

        def Minus(self):
            return self.getToken(FlukaParser.Minus, 0)

        def Plus(self):
            return self.getToken(FlukaParser.Plus, 0)

        def getRuleIndex(self):
            return FlukaParser.RULE_unaryExpression

        def enterRule(self, listener):
            if hasattr(listener, "enterUnaryExpression"):
                listener.enterUnaryExpression(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnaryExpression"):
                listener.exitUnaryExpression(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitUnaryExpression"):
                return visitor.visitUnaryExpression(self)
            else:
                return visitor.visitChildren(self)




    def unaryExpression(self):

        localctx = FlukaParser.UnaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_unaryExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            _la = self._input.LA(1)
            if not(_la==FlukaParser.Plus or _la==FlukaParser.Minus):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 155
            self.match(FlukaParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GeoDirectiveContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.GeoDirectiveContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expansion(self):
            return self.getTypedRuleContext(FlukaParser.ExpansionContext,0)


        def translat(self):
            return self.getTypedRuleContext(FlukaParser.TranslatContext,0)


        def transform(self):
            return self.getTypedRuleContext(FlukaParser.TransformContext,0)


        def getRuleIndex(self):
            return FlukaParser.RULE_geoDirective

        def enterRule(self, listener):
            if hasattr(listener, "enterGeoDirective"):
                listener.enterGeoDirective(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGeoDirective"):
                listener.exitGeoDirective(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitGeoDirective"):
                return visitor.visitGeoDirective(self)
            else:
                return visitor.visitChildren(self)




    def geoDirective(self):

        localctx = FlukaParser.GeoDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_geoDirective)
        try:
            self.state = 160
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [FlukaParser.StartExpansion]:
                self.enterOuterAlt(localctx, 1)
                self.state = 157
                self.expansion()
                pass
            elif token in [FlukaParser.StartTranslat]:
                self.enterOuterAlt(localctx, 2)
                self.state = 158
                self.translat()
                pass
            elif token in [FlukaParser.StartTransform]:
                self.enterOuterAlt(localctx, 3)
                self.state = 159
                self.transform()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpansionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.ExpansionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def StartExpansion(self):
            return self.getToken(FlukaParser.StartExpansion, 0)

        def Float(self):
            return self.getToken(FlukaParser.Float, 0)

        def EndExpansion(self):
            return self.getToken(FlukaParser.EndExpansion, 0)

        def body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.BodyContext)
            else:
                return self.getTypedRuleContext(FlukaParser.BodyContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_expansion

        def enterRule(self, listener):
            if hasattr(listener, "enterExpansion"):
                listener.enterExpansion(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitExpansion"):
                listener.exitExpansion(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitExpansion"):
                return visitor.visitExpansion(self)
            else:
                return visitor.visitChildren(self)




    def expansion(self):

        localctx = FlukaParser.ExpansionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_expansion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.match(FlukaParser.StartExpansion)
            self.state = 163
            self.match(FlukaParser.Float)
            self.state = 165 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 164
                self.body()
                self.state = 167 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.BodyCode) | (1 << FlukaParser.StartExpansion) | (1 << FlukaParser.StartTranslat) | (1 << FlukaParser.StartTransform))) != 0)):
                    break

            self.state = 169
            self.match(FlukaParser.EndExpansion)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TranslatContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.TranslatContext, self).__init__(parent, invokingState)
            self.parser = parser

        def StartTranslat(self):
            return self.getToken(FlukaParser.StartTranslat, 0)

        def Float(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.Float)
            else:
                return self.getToken(FlukaParser.Float, i)

        def EndTranslat(self):
            return self.getToken(FlukaParser.EndTranslat, 0)

        def body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.BodyContext)
            else:
                return self.getTypedRuleContext(FlukaParser.BodyContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_translat

        def enterRule(self, listener):
            if hasattr(listener, "enterTranslat"):
                listener.enterTranslat(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTranslat"):
                listener.exitTranslat(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTranslat"):
                return visitor.visitTranslat(self)
            else:
                return visitor.visitChildren(self)




    def translat(self):

        localctx = FlukaParser.TranslatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_translat)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 171
            self.match(FlukaParser.StartTranslat)
            self.state = 172
            self.match(FlukaParser.Float)
            self.state = 173
            self.match(FlukaParser.Float)
            self.state = 174
            self.match(FlukaParser.Float)
            self.state = 176 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 175
                self.body()
                self.state = 178 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.BodyCode) | (1 << FlukaParser.StartExpansion) | (1 << FlukaParser.StartTranslat) | (1 << FlukaParser.StartTransform))) != 0)):
                    break

            self.state = 180
            self.match(FlukaParser.EndTranslat)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TransformContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.TransformContext, self).__init__(parent, invokingState)
            self.parser = parser

        def StartTransform(self):
            return self.getToken(FlukaParser.StartTransform, 0)

        def EndTransform(self):
            return self.getToken(FlukaParser.EndTransform, 0)

        def ID(self):
            return self.getToken(FlukaParser.ID, 0)

        def Integer(self):
            return self.getToken(FlukaParser.Integer, 0)

        def body(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(FlukaParser.BodyContext)
            else:
                return self.getTypedRuleContext(FlukaParser.BodyContext,i)


        def getRuleIndex(self):
            return FlukaParser.RULE_transform

        def enterRule(self, listener):
            if hasattr(listener, "enterTransform"):
                listener.enterTransform(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTransform"):
                listener.exitTransform(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTransform"):
                return visitor.visitTransform(self)
            else:
                return visitor.visitChildren(self)




    def transform(self):

        localctx = FlukaParser.TransformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_transform)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(FlukaParser.StartTransform)
            self.state = 183
            _la = self._input.LA(1)
            if not(_la==FlukaParser.Integer or _la==FlukaParser.ID):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 185 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 184
                self.body()
                self.state = 187 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << FlukaParser.BodyCode) | (1 << FlukaParser.StartExpansion) | (1 << FlukaParser.StartTranslat) | (1 << FlukaParser.StartTransform))) != 0)):
                    break

            self.state = 189
            self.match(FlukaParser.EndTransform)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LatticeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(FlukaParser.LatticeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def Lattice(self):
            return self.getToken(FlukaParser.Lattice, 0)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(FlukaParser.ID)
            else:
                return self.getToken(FlukaParser.ID, i)

        def getRuleIndex(self):
            return FlukaParser.RULE_lattice

        def enterRule(self, listener):
            if hasattr(listener, "enterLattice"):
                listener.enterLattice(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLattice"):
                listener.exitLattice(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitLattice"):
                return visitor.visitLattice(self)
            else:
                return visitor.visitChildren(self)




    def lattice(self):

        localctx = FlukaParser.LatticeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_lattice)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self.match(FlukaParser.Lattice)
            self.state = 193 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 192
                self.match(FlukaParser.ID)
                self.state = 195 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==FlukaParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





